//<subroutineDec>
          //<parameterList>
  //</parameterList>
    //<subroutineBody>
        //<varDec>
                            //</varDec>
function Main.main 1
    //<statements>
      //<doStatement>
                                // after collecting subroutine name: ( Main.fillMemory
                //<expressionList>
          //<expression>
            //<term>
              push constant 8001
            //</term>
          //</expression>
          //eating comma >>>,
          //<expression>
            //<term>
              push constant 16
            //</term>
          //</expression>
          //eating comma >>>,
          //<expression>
            //<term>
                            //<term>
                push constant 1
              //</term>
neg
            //</term>
          //</expression>
//After completing expression list: )
        //</expressionList>
// after expression_list: )
        call Main.fillMemory 3
        // after compile_do: let
pop temp 0
      //</doStatement>
// current keyword: let
      //<letStatement>
                push local 0
                //<expression>
          //<term>
                                    // after collecting subroutine name: ( Memory.peek
                        //<expressionList>
              //<expression>
                //<term>
                  push constant 8000
                //</term>
              //</expression>
//After completing expression list: )
            //</expressionList>
// after expression_list: )
            call Memory.peek 1
          //</term>
        //</expression>
        pop local 0
      //</letStatement>
// current keyword: do
      //<doStatement>
                                // after collecting subroutine name: ( Main.convert
                //<expressionList>
          //<expression>
            //<term>
              push local 0
            //</term>
          //</expression>
//After completing expression list: )
        //</expressionList>
// after expression_list: )
        call Main.convert 1
        // after compile_do: return
pop temp 0
      //</doStatement>
// current keyword: return
      //<returnStatement>
        push constant 0
return
              //</returnStatement>
// current keyword: }
    //</statements>
      //</subroutineBody>
//</subroutineDec>
//<subroutineDec>
          //<parameterList>
          //</parameterList>
    //<subroutineBody>
        //<varDec>
                                        //</varDec>
    //<varDec>
                            //</varDec>
function Main.convert 3
    //<statements>
      //<letStatement>
                push local 2
                //<expression>
          //<term>
            push constant 1
neg
          //</term>
        //</expression>
        pop local 2
      //</letStatement>
// current keyword: while
      //<whileStatement>
        label while1
                //<expression>
          //<term>
            push local 2
          //</term>
        //</expression>
not
if-goto while_end1
                        //<statements>
          //<letStatement>
                        push local 1
                        //<expression>
              //<term>
                push local 1
              //</term>
              Ate operator: +
              //<term>
                push constant 1
              //</term>
add
            //</expression>
            pop local 1
          //</letStatement>
// current keyword: let
          //<letStatement>
                        push local 0
                        //<expression>
              //<term>
                                                // after collecting subroutine name: ( Main.nextMask
                                //<expressionList>
                  //<expression>
                    //<term>
                      push local 0
                    //</term>
                  //</expression>
//After completing expression list: )
                //</expressionList>
// after expression_list: )
                call Main.nextMask 1
              //</term>
            //</expression>
            pop local 0
          //</letStatement>
// current keyword: if
          //<ifStatement>
                                    //<expression>
              //<term>
                                //<term>
                                    //<expression>
                    //<term>
                      push local 1
                    //</term>
                    Ate operator: >
                    //<term>
                      push constant 16
                    //</term>
gt
                  //</expression>
                  compile_term -> line 515, expecting a ')', ate: )
                //</term>
not
              //</term>
            //</expression>
            Expecting eating ')', ate: )
not
if-goto else_lbl2
            Expecting eating '{', ate: {
            //<statements>
              //<ifStatement>
                                                //<expression>
                  //<term>
                                        //<term>
                                            //<expression>
                        //<term>
                                                    //<expression>
                            //<term>
                              push argument 0
                            //</term>
                            Ate operator: &
                            //<term>
                              push local 0
                            //</term>
and
                          //</expression>
                          compile_term -> line 515, expecting a ')', ate: )
                        //</term>
                        Ate operator: =
                        //<term>
                          push constant 0
                        //</term>
eq
                      //</expression>
                      compile_term -> line 515, expecting a ')', ate: )
                    //</term>
not
                  //</term>
                //</expression>
                Expecting eating ')', ate: )
not
if-goto else_lbl3
                Expecting eating '{', ate: {
                //<statements>
                  //<doStatement>
                                                                                // after collecting subroutine name: ( Memory.poke
                                        //<expressionList>
                      //<expression>
                        //<term>
                          push constant 8000
                        //</term>
                        Ate operator: +
                        //<term>
                          push local 1
                        //</term>
add
                      //</expression>
                      //eating comma >>>,
                      //<expression>
                        //<term>
                          push constant 1
                        //</term>
                      //</expression>
//After completing expression list: )
                    //</expressionList>
// after expression_list: )
                    call Memory.poke 2
                    // after compile_do: }
pop temp 0
                  //</doStatement>
// current keyword: }
                //</statements>
                goto if_done3
label else_lbl3
checking if there's an else:else
                                                //<statements>
                  //<doStatement>
                                                                                // after collecting subroutine name: ( Memory.poke
                                        //<expressionList>
                      //<expression>
                        //<term>
                          push constant 8000
                        //</term>
                        Ate operator: +
                        //<term>
                          push local 1
                        //</term>
add
                      //</expression>
                      //eating comma >>>,
                      //<expression>
                        //<term>
                          push constant 0
                        //</term>
                      //</expression>
//After completing expression list: )
                    //</expressionList>
// after expression_list: )
                    call Memory.poke 2
                    // after compile_do: }
pop temp 0
                  //</doStatement>
// current keyword: }
                //</statements>
                label if_done3
              //</ifStatement>
// current keyword: }
            //</statements>
            goto if_done2
label else_lbl2
checking if there's an else:else
                                    //<statements>
              //<letStatement>
                                push local 2
                                //<expression>
                  //<term>
                    push constant 0
                  //</term>
                //</expression>
                pop local 2
              //</letStatement>
// current keyword: }
            //</statements>
            label if_done2
          //</ifStatement>
// current keyword: }
        //</statements>
goto while1
              //</whileStatement>
// current keyword: return
      //<returnStatement>
        push constant 0
return
              //</returnStatement>
// current keyword: }
    //</statements>
      //</subroutineBody>
//</subroutineDec>
//<subroutineDec>
          //<parameterList>
          //</parameterList>
    //<subroutineBody>
    function Main.nextMask 0
    //<statements>
      //<ifStatement>
                        //<expression>
          //<term>
            push argument 0
          //</term>
          Ate operator: =
          //<term>
            push constant 0
          //</term>
eq
        //</expression>
        Expecting eating ')', ate: )
not
if-goto else_lbl4
        Expecting eating '{', ate: {
        //<statements>
          //<returnStatement>
                        //<expression>
              //<term>
                push constant 1
              //</term>
            //</expression>
return
                      //</returnStatement>
// current keyword: }
        //</statements>
        goto if_done4
label else_lbl4
checking if there's an else:else
                        //<statements>
          //<returnStatement>
                        //<expression>
              //<term>
                push argument 0
              //</term>
              Ate operator: *
              //<term>
                push constant 2
              //</term>
call Math.multiply 2
            //</expression>
return
                      //</returnStatement>
// current keyword: }
        //</statements>
        label if_done4
      //</ifStatement>
// current keyword: }
    //</statements>
      //</subroutineBody>
//</subroutineDec>
//<subroutineDec>
          //<parameterList>
                                  //</parameterList>
    //<subroutineBody>
    function Main.fillMemory 0
    //<statements>
      //<whileStatement>
        label while5
                //<expression>
          //<term>
            push argument 1
          //</term>
          Ate operator: >
          //<term>
            push constant 0
          //</term>
gt
        //</expression>
not
if-goto while_end5
                        //<statements>
          //<doStatement>
                                                // after collecting subroutine name: ( Memory.poke
                        //<expressionList>
              //<expression>
                //<term>
                  push argument 0
                //</term>
              //</expression>
              //eating comma >>>,
              //<expression>
                //<term>
                  push argument 2
                //</term>
              //</expression>
//After completing expression list: )
            //</expressionList>
// after expression_list: )
            call Memory.poke 2
            // after compile_do: let
pop temp 0
          //</doStatement>
// current keyword: let
          //<letStatement>
                        push argument 1
                        //<expression>
              //<term>
                push argument 1
              //</term>
              Ate operator: -
              //<term>
                push constant 1
              //</term>
sub
            //</expression>
            pop argument 1
          //</letStatement>
// current keyword: let
          //<letStatement>
                        push argument 0
                        //<expression>
              //<term>
                push argument 0
              //</term>
              Ate operator: +
              //<term>
                push constant 1
              //</term>
add
            //</expression>
            pop argument 0
          //</letStatement>
// current keyword: }
        //</statements>
goto while5
              //</whileStatement>
// current keyword: return
      //<returnStatement>
        push constant 0
return
              //</returnStatement>
// current keyword: }
    //</statements>
      //</subroutineBody>
//</subroutineDec>
